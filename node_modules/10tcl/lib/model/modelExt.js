module.exports = function(srv){

	return {

		collection: function( tenant ){
			var collectionName = this.collectionName || this.name
			if ( this.multiTenant && tenant ) collectionName = tenant+'.'+collectionName
			return srv.db.collection( collectionName )
		},
		models: function(){
			return srv.m
		},
		
		getAll: function( options ){
			var self     = this
			  , callback = options.callback
			  , tenant   = options.tenant
			  , query    = options.query ? options.query : {}
			  , config   = options.config ? options.config : { sort : [[ 'audit.when', -1 ]] }

			function afterFind( err, data ){
				var data = data ? JSON.parse( JSON.stringify( data ) ) : undefined
				if ( data ){
					data.each( function( datum ){ self.treatStoreData( datum ) } )
					callback( err, data )
				} else {
					callback( err, [] )
				}
			}

			self.collection( tenant ).find( query, config ).toArray( afterFind )	
		},

		getByQuery: function( options ){
			var self     = this
			  , query    = options.query
			  , callback = options.callback
			  , tenant   = options.tenant
			  , config   = options.config ? options.config : { sort:[[ 'audit.when', -1 ]] }
			
			function afterFind( err, data ){
				var data = data ? JSON.parse( JSON.stringify( data ) ) : undefined
				if ( data ) data.each( function( datum ){ self.treatStoreData( datum ) } )
				callback( err, data )
			}
			self.collection( tenant ).find( query, config ).toArray( afterFind )
		},

		getById: function( options ){
			var self     = this
			  , id       = options.id
			  , callback = options.callback
			  , tenant   = options.tenant
			  , config   = options.config

			function afterFind( err, data ){
				var data = data ? JSON.parse( JSON.stringify( data ) ) : undefined
				if ( data ) self.treatStoreData( data )
				callback( err, data )
			}

			if ( config ) self.collection( tenant ).findById( id, config, afterFind )
			if (!config ) self.collection( tenant ).findById( id, afterFind )
		},

		getByText: function( options ){
			var self     = this
			  , text     = options.text
			  , callback = options.callback
			  , tenant   = options.tenant
			  , config   = options.config ?  options.config : { sort : [[ 'audit.when', -1 ]] }
			  , fields = self.textFields()
			  , qryExp = new RegExp(text, 'i')

			if (fields.length === 0){
				callback( 'no searchable fields', [] )	
			} else {
				var param = {}
				if (fields.length === 1) {
					param[fields[0].name] = qryExp
				} else {
					param.$or = []
					fields.each( function(field){
						var orParam = {}
						orParam[field.name] = qryExp
						param.$or.push( orParam )
					})
				}

				function afterFind( err, data){
					var data =  data ? JSON.parse( JSON.stringify( data ) ) : undefined
					data.each( function( datum ){ self.treatStoreData( datum ) } )
					callback( err, data )		
				}
				self.collection( tenant ).find( param, { sort: sort } ).toArray( afterFind )
			}
		},

		getByPage: function( options ){
			var self       = this
			  , page       = options.page
			  , perPage    = options.perPage
			  , callback   = options.callback
			  , tenant     = options.tenant
			  , query      = options.query
			  , plusPages  = 5
			  , skip       = ( page - 1 ) * perPage
			  , limit      = perPage * plusPages
			  , sort       = (self.sort) ? self.sort : [[ 'audit.when', -1 ]]
			  , config     = { sort: sort, fields: self.formatFields() }
			  , collection = self.collection( tenant )

			function afterFind( err, data ){
				var data = JSON.parse( JSON.stringify( data ) )
				if ( data ){
					callback( err, 
						{
							recordCount: self.recordCount,
							pageCount: Math.ceil( self.recordCount / perPage ),
							data: data.each( function( datum ){ self.treatStoreData( datum ) } )
						} 
					)
				} else {
					callback( err, [] )
				}
			}

			function afterCount( err, recordCount ){
				self.recordCount = recordCount
				if ( skip && recordCount > skip ) config.skip = skip
				if ( recordCount > ( skip + limit ) ) config.limit = limit
				collection.find( query, config ).toArray( afterFind )
			}

			if (  self.recordCount ) afterCount( undefined, self.recordCount )
			if ( !self.recordCount ) collection.count( afterCount )
		},

		insert: function( record, callback, tenant ){
			this.treatFormData( record )
			
			var err = this.check( record )
			if (err.keys().length){
				callback(err)
				return
			}
			
			var self = this
			  , newItem = record

			delete newItem._id

			self.collection( tenant ).insert(newItem, function(err, records){
				if ( err ) {
					callback( err )
				} else {
					var insertedRecords = JSON.parse( JSON.stringify( records ) )
					insertedRecords.each( function( record ){
						self.treatStoreData( record ) 
					})
					callback( err, insertedRecords )
				}
			})
		},

		update: function( record, callback, tenant ){
			this.treatFormData( record )

			var self = this
			  , err = this.check( record )

			if ( err.keys().length ){
				callback(err)
				return
			}

			function afterGet( err, item ){

				if (self.keepVersions) {
					var oldVersion = item.clone()
					delete oldVersion.versions
					if (!item.versions) item.versions = []
					item.versions.push(oldVersion)
				}

				item.merge(record)
				self.fields.forEach( function( field ){ 
					if ( !record[field.name] && 'password' != field.type ) delete item[field.name] 
				})

				var _id = item._id.toString()
				  , options = {safe: true}
				  , clone = item.clone()
				delete clone._id

				self.collection( tenant ).updateById( _id, clone, options, function(err, record){
					self.treatStoreData( record )
					callback( err, record )
				})
			}

			self.collection( tenant ).findById( record._id, afterGet )
		},

		remove: function( _id, user, callback, tenant ){
			
			if ( this.authorized( user ) ){
				this.collection( tenant ).removeById( _id, function(err){ 
					callback(err) 
				} )
			}
		},

		desc: function(data){
			return mustache.render(this.format, data).trim()
		},

		options: function( options ){
			var self = this
			  , query = options.query
			  , optionsCallback = options.callback
			  , tenant = options.tenant
			

			function afterRead( err, data ){
				data = data
						.map(function(r){ return { _id: r._id, desc: self.desc(r) } } )
						// .sortBy('desc')

				optionsCallback( err, data )
			}

			if (query){
				self.getByQuery( { query: query, callback: afterRead, tenant: tenant } )
			} else {
				self.getAll( { callback: afterRead, tenant: tenant } )
			}

		},

		textFields: function(){
			var fields = []
			  , type = this.fields.groupBy('type')

			fields.add( type.undefined.map(function(field){ return field.name }) )
			fields.add( type.string.map(function(field){ return field.name }) )
			fields.add( type.text.map(function(field){ return field.name }) )
		},

		formatFields: function(){
			var self = this
			  , fields = ['_id']
			self.fields.each( function( field ){
				if ( self.format && self.format.has( field.name )) fields.push( field.name )
			})
			return fields
		},

		treatFormData: function( record ){
			this.fields.each( function( field ){
				if ( record[field.name] ) record[field.name] = field.treatFormData( record[ field.name ] )
			})
		},

		treatStoreData: function( record ){
			this.fields.each( function( field ){
				if ( record[field.name] ) record[field.name] = field.treatStoreData( record[ field.name ] )
			})
		},

		authorized: function( user ){
			var restriction = this.onlyFor
			
			if ( restriction ){
				if ( !user.role ) return false
				return this.onlyFor.some( user.role )
			} else {
				return true
			}
		},

		check: function(record){
			var self = this
			  , err = []
			  , user = record.audit.who

			if ( !this.authorized( user ) ){
				if (this.onlyFor.isArray()){
					err.push( 'Alteração restrita aos perfis '+this.onlyFor.join(', ') )
				}else{
					err.push( 'Alteração restrita ao perfil '+this.onlyFor )
				}
			}
			
			this.fields.each(function(field){
				var msgs = field.check( record )
				if ( msgs.length > 0 ) err.push( { field: field.name, messages: msgs } )
			})

			if ( this.validate ){
				var msg = this.validate( record )
				if ( msg ) err.push( msg )
			}

			return err
		},

		fieldsets: function(){
			
			var modelFields = this.fields
			  , fieldsets = [{
			  		_id: Math.floor(Math.random() * 10000),
			  		type: 'general',
			  		name: 'general', 
			  		label: 'Dados Básicos',
			  		fields: [],
			  		general: true
			  }]

			modelFields.each(function( field ){
				if ( 'instance' === field.type ){

					fieldsets.push({
						_id: Math.floor(Math.random() * 10000),
						type: field.type,
						fieldsetName: field.name,
						label: field.label,
						fields: srv.m[field.of].fields,
						general: true
					})
				} else if ( 'list' === field.type ){

					fieldsets.push({
						_id: Math.floor(Math.random() * 10000),
						type: field.type,
						fieldsetName: field.name,
						label: field.label,
						format: srv.m[field.of].format,
						fields: srv.m[field.of].fields,
						list: true
					})
				} else if ( 'html' === field.type ){

					fieldsets.push({
						_id: Math.floor(Math.random() * 10000),
						type: field.type,
						fieldsetName: field.name,
						label: field.label,
						fields: [field],
						html: true
					})
				} else {
					
					fieldsets[0].fields.push(field)
				}
			})

			return fieldsets
		}
	}
	
}